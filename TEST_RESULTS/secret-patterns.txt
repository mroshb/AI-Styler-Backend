./internal/middleware/quota.go:		key := "rate_limit:ip:" + ip
./internal/middleware/quota.go:		count, err := r.redisClient.Get(context.Background(), key).Int()
./internal/middleware/quota.go:		r.redisClient.Incr(context.Background(), key)
./internal/middleware/quota.go:		r.redisClient.Expire(context.Background(), key, window)
./internal/middleware/quota.go:		key := "rate_limit:user:" + userID
./internal/middleware/quota.go:		count, err := r.redisClient.Get(context.Background(), key).Int()
./internal/middleware/quota.go:		r.redisClient.Incr(context.Background(), key)
./internal/middleware/quota.go:		r.redisClient.Expire(context.Background(), key, window)
./internal/middleware/monitoring.go:		// Try both "user_id" and "userID" keys for compatibility
./internal/middleware/monitoring.go:			// This would validate the JWT token
./internal/route/router.go:func (m *mockRateLimiter) Allow(ctx context.Context, key string, limit int, window time.Duration) bool {
./internal/route/router.go:	// Use auth handler's authentication middleware for proper token validation
./internal/route/router.go:			shareGroup.GET("/:token", shareService.(*share.Handler).AccessSharedLink)
./internal/route/router.go:// authMiddlewareForGin converts auth.Handler token validation to Gin middleware
./internal/route/router.go:		token := strings.TrimPrefix(authHeader, "Bearer ")
./internal/route/router.go:		// First try to parse as simple token (userID|role|sessionID format)
./internal/route/router.go:		if userID, role := parseSimpleTokenForAuth(token); userID != "" {
./internal/route/router.go:		// If simple token parsing failed, try to use auth handler's token service
./internal/route/router.go:		claims, err := authHandler.GetTokenService().ValidateAccess(c.Request.Context(), token)
./internal/route/router.go:// parseSimpleTokenForAuth parses a simple base64 encoded token in format: userID|role|sessionID
./internal/route/router.go:func parseSimpleTokenForAuth(token string) (userID, role string) {
./internal/route/router.go:	b, err := base64.StdEncoding.DecodeString(token)
./internal/route/router.go:	tokens := auth.NewSimpleTokenService()
./internal/route/router.go:	h := auth.NewHandler(store, tokens, limiter, smsProvider)
./internal/route/router.go:	return fmt.Sprintf("host=%s port=%d user=%s password=%s dbname=%s sslmode=%s",
./internal/route/router.go:func (r *realRateLimiter) Allow(ctx context.Context, key string, limit int, window time.Duration) bool {
./internal/sms/sms_ir.go:	req.Header.Set("x-api-key", s.APIKey)
./internal/config/config.go:			Secret:     getEnv("JWT_SECRET", "your-secret-key-change-in-production"),
./internal/config/config.go:func getEnv(key, defaultValue string) string {
./internal/config/config.go:	if value := os.Getenv(key); value != "" {
./internal/config/config.go:func getEnvAsInt(key string, defaultValue int) int {
./internal/config/config.go:	if value := os.Getenv(key); value != "" {
./internal/config/config.go:func getEnvAsDuration(key string, defaultValue time.Duration) time.Duration {
./internal/config/config.go:	if value := os.Getenv(key); value != "" {
./internal/config/config.go:func getEnvAsBool(key string, defaultValue bool) bool {
./internal/config/config.go:	if value := os.Getenv(key); value != "" {
./internal/config/config.go:func getEnvAsFloat(key string, defaultValue float64) float64 {
./internal/config/config.go:	if value := os.Getenv(key); value != "" {
./internal/config/production.go:	// Validate JWT secret
./internal/config/production.go:		return fmt.Errorf("JWT secret must be at least 32 characters long")
./internal/config/production.go:	return fmt.Sprintf("host=%s port=%d user=%s password=%s dbname=%s sslmode=%s",
./internal/security/rate_limiter.go:func (rl *RedisRateLimiter) Allow(ctx context.Context, key string, limit int, window time.Duration) bool {
./internal/security/rate_limiter.go:	pipe.ZRemRangeByScore(ctx, key, "0", fmt.Sprintf("%d", windowStart.UnixNano()))
./internal/security/rate_limiter.go:	pipe.ZCard(ctx, key)
./internal/security/rate_limiter.go:	pipe.ZAdd(ctx, key, &redis.Z{
./internal/security/rate_limiter.go:	pipe.Expire(ctx, key, window)
./internal/security/rate_limiter.go:func (rl *RedisRateLimiter) GetRemaining(ctx context.Context, key string, limit int, window time.Duration) int {
./internal/security/rate_limiter.go:	rl.client.ZRemRangeByScore(ctx, key, "0", fmt.Sprintf("%d", windowStart.UnixNano()))
./internal/security/rate_limiter.go:	count, err := rl.client.ZCard(ctx, key).Result()
./internal/security/rate_limiter.go:// Reset clears all requests for a key
